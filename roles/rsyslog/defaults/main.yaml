---
# General configuration
# ---------------------

# .. envvar:: rsyslog_enabled
#
# Enable or disable ``rsyslog`` management.
rsyslog_enabled: True

# .. envvar:: rsyslog_system_log_dir
#
# Top directory to place logs
rsyslog_system_log_dir: '/var/log'

# .. envvar:: rsyslog_config_dir
#
# Configuration directory
rsyslog_config_dir: '/etc/rsyslog.d'

# .. envvar:: rsyslog_viaq_config_dir
#
# Viaq configuration directory
rsyslog_viaq_config_dir: '{{rsyslog_config_dir}}/viaq'

# .. envvar:: rsyslog_viaq_log_dir
#
# Viaq log directory
rsyslog_viaq_log_dir: '{{rsyslog_system_log_dir}}/containers'

# .. envvar:: rsyslog_work_dir
#
# Rsyslog work directory
rsyslog_work_dir: '/var/lib/rsyslog'

# .. envvar:: rsyslog_capabilities
#
# List of different capabilities to configure. See :ref:`rsyslog_capabilities`
# rsyslog_capabilities: [ 'network', 'remote-files', 'tls', 'viaq', 'viaq-k8s' ]
rsyslog_capabilities: []

# .. envvar:: rsyslog_unprivileged
#
# Enable or disable unprivileged ``rsyslogd`` operation. Warning, enabling this
# option requires additional configuration outside of the ``rsyslog``
# role. 
rsyslog_unprivileged: '{{ "True"
                           if (ansible_distribution in [ "CentOS", "RedHat", "Fedora" ])
                           else "False" }}'

# .. envvar:: rsyslog_message_reduction
#
# Enable or disable message reduction. This is disabled by default so that log
# parsers like :program:`fail2ban` can work correctly.
rsyslog_message_reduction: False

# .. envvar:: rsyslog_purge_original_conf
#
# The pre-existing config files are archived in the tempdir and purged if the
# rsyslog_purge_original_conf is set to `True`.  Default to 'False`.
rsyslog_purge_original_conf: False

# rpm packages
# adding rsyslog_logging_packages
# ------------------

# .. envvar:: rsyslog_base_packages
#
# List of default rpm packages to install.
rsyslog_base_packages: [ 'rsyslog', 'libselinux-python' ]

# .. envvar:: rsyslog_logging_packages
#
# List of rpm packages for Common Logging.
rsyslog_viaq_prereq_packages: [ 'nmap-ncat', 'systemd-python', 'policycoreutils', 'checkpolicy', 'policycoreutils-python' ]
rsyslog_viaq_packages: [ 'rsyslog-elasticsearch', 'rsyslog-mmjsonparse', 'rsyslog-mmkubernetes', 'rsyslog-mmnormalize' ]

# .. envvar:: rsyslog_tls_packages
#
# List of rpm packages required for TLS support.
rsyslog_tls_packages: [ 'rsyslog-gnutls', 'ca-certificates' ]

# .. envvar:: rsyslog_packages
#
# List of additional rpm packages to install.
rsyslog_packages: []

# .. envvar:: rsyslog_custom_config_files
#
# List of additional custom config files.
# Each element: full paths to the files to be deployed.
rsyslog_custom_config_files: []


# User, group, home, file ownership
# ---------------------------------

# .. envvar:: rsyslog_user
#
# The unprivileged system user account used by the ``rsyslogd`` daemon, when
# unprivileged operation is enabled.
rsyslog_user: '{{ "syslog" if rsyslog_unprivileged|bool else "root" }}'

# .. envvar:: rsyslog_group
#
# The unprivileged system group account used by the ``rsyslogd`` daemon, when
# unprivileged operation is enabled.
rsyslog_group: '{{ "syslog" if rsyslog_unprivileged|bool else "root" }}'

# .. envvar:: rsyslog_file_owner
#
# The account which will be set as the owner of the log files generated by
# ``rsyslogd``. When an unprivileged mode is enabled, it should be the same as
# the ``rsyslogd`` user account.
rsyslog_file_owner: '{{ rsyslog_user }}'

# .. envvar:: rsyslog_file_group
#
# The system group which will be set as the default group of the log files
# generated by ``rsyslogd``.
rsyslog_file_group: 'root'

# Available configuration set
# ----------------------------

# Enable or disable defined rsyslog config sets
rsyslog_example: 'False'
rsyslog_viaq: 'False'

rsyslog_elasticsearch_viaq:
  - name: viaq-elasticsearch
    server_host: logging-es
    server_port: 9200
    ca_cert: "{{rsyslog_viaq_config_dir}}/es-ca.crt"
    cert: "{{rsyslog_viaq_config_dir}}/es-cert.pem"
    key: "{{rsyslog_viaq_config_dir}}/es-key.pem"

# Encrypted communication
# ------------------------

# .. envvar:: rsyslog_pki
#
# Enable or disable support for X.509 certificates managed by pki_role,
# used for TLS connections.
rsyslog_pki: '{{ True
                  if (ansible_local|d() and ansible_local.pki|d() and
                      ansible_local.pki.enabled|bool)
                  else False }}'

# .. envvar:: rsyslog_pki_path
#
# Path to the directory with PKI realms.
# (??? - do we set the path to some other place???)
rsyslog_pki_path: '{{ ansible_local.pki.path
                       if (ansible_local|d() and ansible_local.pki|d() and
                           ansible_local.pki.path|d())
                       else "/etc/pki" }}'

# .. envvar:: rsyslog_pki_realm
#
# Name of the PKi realm to use with ``rsyslogd``.
rsyslog_pki_realm: '{{ ansible_local.pki.realm
                        if (ansible_local|d() and ansible_local.pki|d() and
                            ansible_local.pki.realm|d())
                        else "domain" }}'

# .. envvar:: rsyslog_pki_ca
#
# Name of the root CA certificate used by the ``rsyslog`` role.
rsyslog_pki_ca: '{{ ansible_local.pki.ca
                      if (ansible_local|d() and ansible_local.pki|d() and
                          ansible_local.pki.ca|d())
                      else "CA.crt" }}'

# .. envvar:: rsyslog_pki_crt
#
# Name of the client certificate file used by the ``rsyslog`` role.
rsyslog_pki_crt: '{{ ansible_local.pki.crt
                      if (ansible_local|d() and ansible_local.pki|d() and
                          ansible_local.pki.crt|d())
                      else "default.crt" }}'

# .. envvar:: rsyslog_pki_key
#
# Name of the private key file used by the ``rsyslog`` role.
rsyslog_pki_key: '{{ ansible_local.pki.key
                      if (ansible_local|d() and ansible_local.pki|d() and
                          ansible_local.pki.key|d())
                      else "default.key" }}'

# .. envvar:: rsyslog_default_netstream_driver
#
# Specify the default netstrap driver used by the ``imtcp`` module. The
# ``gtls`` will be enabled by default if the support for PKI is enabled,
# otherwise ``ptcp`` will be used.
rsyslog_default_netstream_driver: '{{ "gtls"
                                       if (rsyslog_pki|bool and
                                           "tls" in rsyslog_capabilities)
                                       else "ptcp" }}'

# .. envvar:: rsyslog_default_driver_authmode
#
# Specify the default network driver authetication mode. Actualy only
# `x509/name` or `anon` are available:
rsyslog_default_driver_authmode: "x509/name"

# .. envvar:: rsyslog_send_over_tls
#
# This configuration is added to the forward options when ``tls`` capability is
# enabled. It's used to configure TLS options.
rsyslog_send_over_tls: |-
  $ActionSendStreamDriver gtls
  $ActionSendStreamDriverAuthMode {{ rsyslog_default_driver_authmode }}
  {% if rsyslog_default_driver_authmode != "anon" %}
  {%   if rsyslog_send_permitted_peers is string %}
  $ActionSendStreamDriverPermittedPeer {{ rsyslog_send_permitted_peers }}
  {%   else %}
  {%     for peer in rsyslog_send_permitted_peers %}
  $ActionSendStreamDriverPermittedPeer {{ peer }}
  {%     endfor %}
  {%   endif %}
  {% endif %}
  $ActionSendStreamDriverMode 1

# .. envvar:: rsyslog_send_over_tls_only
#
# Specify if you want only TLS communications.
rsyslog_send_over_tls_only: False

# .. envvar:: rsyslog_domain
#
# The default DNS domain used to accept remote incoming logs from remote hosts.
rsyslog_domain: '{{ ansible_domain if ansible_domain else ansible_hostname }}'

# .. envvar:: rsyslog_permitted_peers
#
# List of hostnames, IP addresses or wildcard DNS domains which will be allowed
# by the ``rsyslogd`` server to connect and send logs over TLS.
rsyslog_permitted_peers: [ '*.{{ rsyslog_domain }}' ]

# .. envvar:: rsyslog_send_permitted_peers
#
# List of hostnames, IP addresses or wildcard DNS domains which will be
# verified by the ``rsyslogd`` client and will allow to send logs to the remote
# server over TLS.
rsyslog_send_permitted_peers: '{{ rsyslog_permitted_peers }}'


# Firewall, UDP, TCP ports
# ------------------------

# .. envvar:: rsyslog_udp_port
#
# The incoming UDP port used for remote logging.
rsyslog_udp_port: '514'

# .. envvar:: rsyslog_tcp_port
#
# The incoming TCP port used for remote logging.
rsyslog_tcp_port: '514'

# .. envvar:: rsyslog_tcp_tls_port
#
# The incoming TCP TLS port used for remote logging.
rsyslog_tcp_tls_port: '6514'

# .. envvar:: rsyslog_allow
#
# List of IP addresses or CIDR subnets which should be allowed to connect to
# ``rsyslogd`` ports by the firewall. This variable should be used for all
# hosts in the inventory.
rsyslog_allow: []

# .. envvar:: rsyslog_group_allow
#
# List of IP addresses or CIDR subnets which should be allowed to connect to
# ``rsyslogd`` ports by the firewall. This variable should be used for specific
# group of hosts in the inventory.
rsyslog_group_allow: []

# .. envvar:: rsyslog_host_allow
#
# List of IP addresses or CIDR subnets which should be allowed to connect to
# ``rsyslogd`` ports by the firewall. This variable should be used for specific
# hosts in the inventory.
rsyslog_host_allow: [ '192.168.122.100/24' ]


# Log forwarding
# --------------

# .. envvar:: rsyslog_forward
#
# List of ``rsyslogd`` options that configure log forwarding for all hosts in
# the inventory.
rsyslog_forward: []

# .. envvar:: rsyslog_group_forward
#
# List of ``rsyslogd`` options that configure log forwarding for hosts in
# a specific group.
rsyslog_group_forward: []

# .. envvar:: rsyslog_host_forward
#
# List of ``rsyslogd`` options that configure log forwarding for specific hosts
# in Ansible inventory.
# rsyslog_host_forward: [ '*.* @other.{{ ansible_domain }}' ]
rsyslog_host_forward: []


# Rsyslog configuration rules
# ---------------------------

# .. envvar:: rsyslog_weight_map
#
# This is a dictionary map of different configuration "types" corresponding to
# numbers used to sort configuration files in :file:`{{rsyslog_config_dir}}` directory
# (configuration order is important). You can specify a type in the
# configuration by using the ``item.type`` parameter.
#
# If you change the default weight map values, you will most likely need to
# remove all files from :file:`{{rsyslog_config_dir}}` to reset the configuration.
#
# See :ref:`rsyslog_rules` for more details.
rsyslog_weight_map:
  'global':    '05'
  'globals':   '05'
  'module':    '10'
  'modules':   '10'
  'template':  '20'
  'templates': '20'
  'output':    '30'
  'outputs':   '30'
  'service':   '30'
  'services':  '30'
  'rule':      '50'
  'rules':     '50'
  'ruleset':   '50'
  'rulesets':  '50'
  'input':     '90'
  'inputs':    '90'

# .. envvar:: rsyslog_rules
#
# List of YAML dictionaries, each dictionary should contain ``rsyslogd``
# configuration in a special format. See :ref:`rsyslog_rules` for more
# details. This list should be used for configuration of all hosts in the
# inventory.
rsyslog_rules: []

# .. envvar:: rsyslog_group_rules
#
# List of YAML dictionaries, each dictionary should contain ``rsyslogd``
# configuration in a special format. See :ref:`rsyslog_rules` for more
# details. This list should be used for configuration of a group of hosts in
# the inventory.
rsyslog_group_rules: []

# .. envvar:: rsyslog_host_rules
#
# List of YAML dictionaries, each dictionary should contain ``rsyslogd``
# configuration in a special format. See :ref:`rsyslog_rules` for more
# details. This list should be used for configuration of specific hosts in the
# inventory.
rsyslog_host_rules: []

# .. envvar:: rsyslog_dependent_rules
#
# List of YAML dictionaries, each dictionary should contain ``rsyslogd``
# configuration in a special format. See :ref:`rsyslog_rules` for more
# details. This list should be used for configuration by other Ansible roles.
rsyslog_dependent_rules: []

# .. envvar:: rsyslog_default_rules
#
# List of YAML dictionaries, each dictionary should contain ``rsyslogd``
# configuration in a special format. See :ref:`rsyslog_rules` for more
# details. This lis specifies default ``rsyslogd`` configuration enabled in the
# role.
rsyslog_default_rules:

  - '{{ rsyslog_conf_global_options }}'
  - '{{ rsyslog_conf_local_modules }}'
  - '{{ rsyslog_conf_network_modules }}'
  - '{{ rsyslog_conf_common_defaults }}'
  - '{{ rsyslog_conf_filename_templates }}'
  - '{{ rsyslog_conf_remote_forward }}'
  - '{{ rsyslog_conf_default_rulesets }}'
  - '{{ rsyslog_conf_system_rules }}'
  - '{{ rsyslog_conf_system_cron }}'
  - '{{ rsyslog_conf_network_input }}'
  - '{{ rsyslog_conf_dynamic_logs }}'
  - '{{ rsyslog_conf_stop_remote }}'

rsyslog_viaq_rules:

  - '{{ rsyslog_conf_global_options }}'
  - '{{ rsyslog_conf_local_modules }}'
  - '{{ rsyslog_conf_network_modules }}'
  - '{{ rsyslog_conf_common_defaults }}'
  - '{{ rsyslog_conf_viaq_main_modules }}'
  - '{{ rsyslog_conf_viaq_mmk8s }}'
  - '{{ rsyslog_conf_viaq_elasticsearch }}'
  - '{{ rsyslog_conf_viaq_viaq_formatting }}'
  - '{{ rsyslog_rulebase_viaq_k8s_filename }}'
  - '{{ rsyslog_rulebase_viaq_parse_json }}'
  - '{{ rsyslog_rulebase_viaq_k8s_container_name }}'
  - '{{ rsyslog_json_viaq_normalize_level }}'
  - '{{ rsyslog_json_viaq_prio_to_level }}'
  - '{{ rsyslog_rulebase_viaq_crio }}'

# Default configuration options [[[
# ---------------------------------

# .. envvar:: rsyslog_conf_global_options
#
# Some of the global ``rsyslogd`` configuration options. See
# http://www.rsyslog.com/doc/v8-stable/rainerscript/global.html for more
# details.
rsyslog_conf_global_options:

  - filename: '00-global.conf'
    comment: 'Global options'
    options: |-
      global(
        defaultNetstreamDriver="{{ rsyslog_default_netstream_driver }}"
        workDirectory="{{ rsyslog_work_dir }}"
      {% if rsyslog_pki|bool and "tls" in rsyslog_capabilities %}
        defaultNetstreamDriverCAFile="{{ rsyslog_pki_path + '/' + rsyslog_pki_realm + '/' + rsyslog_pki_ca }}"
      {%   if rsyslog_default_driver_authmode != "anon" or "network" in rsyslog_capabilities %}
        defaultNetstreamDriverCertFile="{{ rsyslog_pki_path + '/' + rsyslog_pki_realm + '/' + rsyslog_pki_crt }}"
        defaultNetstreamDriverKeyFile="{{ rsyslog_pki_path + '/' + rsyslog_pki_realm + '/' + rsyslog_pki_key }}"
      {%   endif %}
      {% endif %}
      )

# .. envvar:: rsyslog_conf_local_modules
#
# List of ``rsyslogd`` modules that enable logs from the local system to be
# received and parsed by the ``rsyslogd`` daemon.
rsyslog_conf_local_modules:

  - name: 'local-modules'
    type: 'modules'
    sections:

      - comment: 'Log messages sent to local UNIX socket'
        options: module(load="imuxsock" SysSock.use="off")

      - comment: 'Log kernel messages'
        options: |-
          module(load="imklog" permitnonkernelfacility="on")
        state: '{{ "present"
                  if (ansible_local|d() and ansible_local.cap12s|d() and
                      (not ansible_local.cap12s.enabled|bool or
                       "cap_sys_admin" in ansible_local.cap12s.list))
                  else "absent" }}'

      - comment: 'Log periodic -- MARK -- messages'
        options: |-
          module(load="immark" interval={{ (60 * 60) }})
        state: '{{ "present"
                  if ("mark" in rsyslog_capabilities)
                  else "absent" }}'

# .. envvar:: rsyslog_conf_network_modules
#
# List of ``rsyslogd`` modules that receive logs from remote systems over the
# network. They are enabled by the ``network`` capability.
rsyslog_conf_network_modules:

  - name: 'network-modules'
    type: 'modules'
    state: '{{ "present"
              if ("network" in rsyslog_capabilities)
              else "absent" }}'
    sections:

      - comment: 'Enable UDP support'
        options: |-
          module(load="imudp")
        state: '{{ "present"
                  if (rsyslog_send_over_tls_only)
                  else "absent" }}'

      - comment: 'Enable TCP support'
        options: |-
          module(load="imptcp")
        state: '{{ "present"
                  if (rsyslog_send_over_tls_only)
                  else "absent" }}'

      - comment: 'Enable GnuTLS TCP support'
        options: |-
          module(
            load="imtcp"
            streamDriver.name="gtls"
            streamDriver.mode="1"
            streamDriver.authMode="{{ rsyslog_default_driver_authmode }}"
          {% if rsyslog_default_driver_authmode != "anon" %}
            {% if rsyslog_permitted_peers is string %}
              permittedPeer="{{ rsyslog_permitted_peers }}"
            {% else %}
              permittedPeer=["{{ rsyslog_permitted_peers | join('","') }}"]
            {% endif %}
          {% endif %}
          )
        state: '{{ "present"
                  if ("tls" in rsyslog_capabilities)
                  else "absent" }}'

                                                                   # ]]]
# .. envvar:: rsyslog_conf_network_input [[[
#
# Configuration of UDP, TCP and TCP over TLS inputs to receive logs from remote
# hosts, enabled by the ``network`` capability.
rsyslog_conf_network_input:

  - name: 'network-input'
    type: 'input'
    state: '{{ "present"
              if ("network" in rsyslog_capabilities)
              else "absent" }}'
    sections:

      - comment: 'Log messages from remote hosts over UDP'
        options: |-
          input(
            type="imudp"
            port="{{ rsyslog_udp_port }}"
            ruleset="remote"
          )
        state: '{{ "present"
                  if (not rsyslog_send_over_tls_only)
                  else "absent" }}'

      - comment: 'Log messages from remote hosts over TCP'
        options: |-
          input(
            type="imptcp"
            port="{{ rsyslog_tcp_port }}"
            ruleset="remote"
          )
        state: '{{ "present"
                  if (not rsyslog_send_over_tls_only)
                  else "absent" }}'

      - comment: 'Log messages from remote hosts over TLS'
        options: |-
          input(
            type="imtcp"
            name="imtls"
            port="{{ rsyslog_tcp_tls_port }}"
            ruleset="remote"
          )
        state: '{{ "present"
                  if ("tls" in rsyslog_capabilities)
                  else "absent" }}'

# .. envvar:: rsyslog_conf_common_defaults
#
# List of common ``rsyslogd`` configuration, like new file owner/group and
# permissions, work directory, configuration of message reduction.
rsyslog_conf_common_defaults:

  - name: 'common-defaults'
    type: 'global'
    sections:

      - comment: 'Set default permissions for all log files'
        options: |-
          $FileOwner {{ rsyslog_file_owner }}
          $FileGroup {{ rsyslog_file_group }}
          $FileCreateMode 0640
          $DirCreateMode 0755
          $Umask 0022
          {% if rsyslog_unprivileged|bool %}
          $PrivDropToUser {{ rsyslog_user }}
          $PrivDropToGroup {{ rsyslog_group }}
          {% endif %}

      - comment: 'Log every message'
        options: |-
          $RepeatedMsgReduction {{ "on" if rsyslog_message_reduction|bool else "off" }}

# .. envvar:: rsyslog_conf_filename_templates
#
# List of ``rsyslogd`` templates which are used to generate dynamic filenames
# for remote logs, based on hostnames. You can add additional template
# configuration by writing it in the :file:`{{rsyslog_config_dir}}/*.template` files, they
# will be included by the main configuration.
rsyslog_conf_filename_templates:

  - name: 'templates'
    type: 'template'
    sections:

      - comment: 'Remote host system logs'
        options: |-
          template(
            name="RemoteHostSyslog"
            type="string"
            string="{{rsyslog_system_log_dir}}/remote/hosts/%HOSTNAME%/syslog"
          )

      - comment: 'Remote host auth logs'
        options: |-
          template(
            name="RemoteHostAuthLog"
            type="string"
            string="{{rsyslog_system_log_dir}}/remote/hosts/%HOSTNAME%/auth.log"
          )

      - comment: 'Remote host cron logs'
        options: |-
          template(
            name="RemoteHostCronLog"
            type="string"
            string="{{rsyslog_system_log_dir}}/remote/hosts/%HOSTNAME%/cron.log"
          )

      - comment: 'Remote service auth logs'
        options: |-
          template(
            name="RemoteServiceAuthLog"
            type="string"
            string="{{rsyslog_system_log_dir}}/remote/services/auth/auth.log"
          )

      - comment: 'Remote service cron logs'
        options: |-
          template(
            name="RemoteServiceCronLog"
            type="string"
            string="{{rsyslog_system_log_dir}}/remote/services/cron/cron.log"
          )

      - comment: 'Remote service mail logs'
        options: |-
          template(
            name="RemoteServiceMailLog"
            type="string"
            string="{{rsyslog_system_log_dir}}/remote/services/mail/mail.log"
          )

      - comment: 'Include custom templates'
        options: |-
          $IncludeConfig {{rsyslog_config_dir}}/*.template

      - comment: 'Use traditional timestamp format'
        options: |-
          $ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat

# .. envvar:: rsyslog_conf_remote_forward
#
# Enable log forwardin to another ``rsyslogd`` instance if it's enabled in
# :envvar:`rsyslog_forward` variables.
rsyslog_conf_remote_forward:

  - filename: '20-remote-forward.system'
    state: '{{ "present"
               if (rsyslog_forward|d() or rsyslog_group_forward|d() or rsyslog_host_forward|d())
               else "absent" }}'

    sections:

      - comment: 'Forward logs over TLS by default'
        options: '{{ rsyslog_send_over_tls }}'
        state: '{{ "present"
                   if (rsyslog_pki|bool and
                       "tls" in rsyslog_capabilities)
                   else "absent" }}'

      - comment: 'Forward logs to specified hosts'
        options: |-
          {% for element in (rsyslog_forward + rsyslog_group_forward + rsyslog_host_forward) %}
          {{ element }}
          {% endfor %}

# .. envvar:: rsyslog_conf_default_rulesets [[[
#
# The ``rsyslogd`` configuration can contain multiple rulesets, each one
# connected to an input channel (see
# http://www.rsyslog.com/doc/v8-stable/concepts/multi_ruleset.html for more
# details).
#
# By default ``rsyslog`` use the default ruleset for local system logs, 
# and defines a separate ``remote`` ruleset for logs incoming over the
# network from remote hosts. The local log rules are stored in
# :file:`{{rsyslog_config_dir}}/*.system` configuration files, and remote log
# rules are stored in :file:`{{rsyslog_config_dir}}/*.remote` configuration files.
rsyslog_conf_default_rulesets:

  - name: 'default-rulesets'
    type: 'rules'
    sections:

      - comment: 'Rules for the local system logs'
        options: |-
          $IncludeConfig {{rsyslog_config_dir}}/*.system

      - comment: 'Rules for logs incoming from remote hosts'
        options: |-
          ruleset(name="remote") {
            $IncludeConfig {{rsyslog_config_dir}}/*.remote
          }

# .. envvar:: rsyslog_conf_system_rules
#
# A set of default ``rsyslog`` options which store local system logs in files
# located in :file:`{{rsyslog_system_log_dir}}/` directory. This is mostly the same as the default
# ``rsyslogd`` configuration provided in Debian/Ubuntu installations.
rsyslog_conf_system_rules:

  - filename: '50-default-rules.system'
    sections:

      - comment: |-
          Log all kernel messages to the console.
          Logging much else clutters up the screen.
        options: |-
          #kern.*                                                 /dev/console

      - comment: |-
          Log anything (except mail) of level info or higher.
          Don't log private authentication messages!
        options: |-
          *.info;mail.none;authpriv.none;cron.none                {{rsyslog_system_log_dir}}/messages

      - comment: 'The authpriv file has restricted access.'
        options: |-
          authpriv.*                                              {{rsyslog_system_log_dir}}/secure

      - comment: 'Log all the mail messages in one place.'
        options: |-
          mail.*                                                  -{{rsyslog_system_log_dir}}/maillog

      - comment: 'Log cron stuff'
        options: |-
          cron.*                                                  -{{rsyslog_system_log_dir}}/cron

      - comment: 'Everybody gets emergency messages'
        options: |-
          *.emerg                                                  :omusrmsg:*

      - comment: 'Save news errors of level crit and higher in a special file.'
        options: |-
          uucp,news.crit                                          {{rsyslog_system_log_dir}}/spooler

      - comment: 'Save boot messages also to boot.log'
        options: |-
          local7.*                                                {{rsyslog_system_log_dir}}/boot.log

# .. envvar:: rsyslog_conf_system_cron
#
# Configuration for system :program:`cron` logs. This will ensure that :program:`cron` logs
# will be stored in separate :file:`{{rsyslog_system_log_dir}}/cron.log` file and won't clutter auth
# or syslog logs.
rsyslog_conf_system_cron:
  filename: '40-cron.system'
  options: |
    if ($msg contains "pam_unix(cron:session): session opened for user") then {
      action(type="omfile" file="{{rsyslog_system_log_dir}}/cron.log")
    {% if 'remote-files' in rsyslog_capabilities %}
      action(type="omfile" DynaFile="RemoteHostCronLog")
      action(type="omfile" DynaFile="RemoteServiceCronLog")
    {% endif %}
      stop
    } else if ($msg contains "pam_unix(cron:session): session closed for user") then {
      action(type="omfile" file="{{rsyslog_system_log_dir}}/cron.log")
    {% if 'remote-files' in rsyslog_capabilities %}
      action(type="omfile" DynaFile="RemoteHostCronLog")
      action(type="omfile" DynaFile="RemoteServiceCronLog")
    {% endif %}
      stop
    }

# .. envvar:: rsyslog_conf_dynamic_logs
#
# List of ``rsyslogd`` rules which maintain dynamic log files in
# :file:`{{rsyslog_system_log_dir}}/remote/` directory. These log files will store
# logs incoming from other, remote hosts.
rsyslog_conf_dynamic_logs:

  - filename: '40-dynamic-cron.remote'
    options: |
      if ($msg contains "pam_unix(cron:session): session opened for user") then {
        action(type="omfile" DynaFile="RemoteHostCronLog")
        action(type="omfile" DynaFile="RemoteServiceCronLog")
        stop
      } else if ($msg contains "pam_unix(cron:session): session closed for user") then {
        action(type="omfile" DynaFile="RemoteHostCronLog")
        action(type="omfile" DynaFile="RemoteServiceCronLog")
        stop
      }
    state: '{{ "present"
               if ("remote-files" in rsyslog_capabilities)
               else "absent" }}'

  - filename: '50-dynamic-logs.remote'
    comment: 'Store remote logs in separate logfiles'
    options: |-
      authpriv.*                          ?RemoteHostAuthLog
      authpriv.*                          ?RemoteServiceAuthLog
      *.*;cron,authpriv.none              -?RemoteHostSyslog
      cron.*                              -?RemoteHostCronLog
      cron.*                              -?RemoteServiceCronLog
      mail.*                              -?RemoteServiceMailLog
    state: '{{ "present"
               if ("remote-files" in rsyslog_capabilities)
               else "absent" }}'

# .. envvar:: rsyslog_conf_stop_remote
#
# The older ``rsyslogd`` versions do not support empty rulesets. This
# configuration file is used to allow empty ``remote`` ruleset when remote log
# support is disabled, and should be included in the configuration at the very
# end.
rsyslog_conf_stop_remote:

  - filename: 'zz-stop.remote'
    comment: |-
      This is a workaround to support empty "remote" ruleset on
      older versions of rsyslog package.
      http://comments.gmane.org/gmane.comp.sysutils.rsyslog/15616
    options: |-
      stop

logging_mmk8s_ca_cert: ''
logging_mmk8s_token: ''

rsyslog_conf_viaq_main_modules:

  - name: 'viaq_main'
    type: 'modules'
    state: "{{ 'present'
               if ('viaq' in rsyslog_capabilities)
               else 'absent' }}"
    sections:

      - options: |-
          # Read from file with inotify enabled
          module(load="imfile" mode="inotify")

      - options: |-
          # Read from journal
          module(load="imjournal" StateFile="{{ rsyslog_work_dir }}/imjournal.state" UsePid="both" RateLimit.Burst="{{ imjournal_ratelimit_burst|default(1000000) }}" RateLimit.Interval="{{ imjournal_ratelimit_interval|default(10) }}" PersistStateInterval="1000" WorkAroundJournalBug="on")

      - options: |-
          # Normalize logs
          module(load="mmnormalize")

      - options: |-
          # Parse logs to JSON
          module(load="mmjsonparse")

      - options: |-
          # Send to ElasticSearch
          module(load="omelasticsearch")

      - options: |-
          # Include viaq config files
          $IncludeConfig {{ rsyslog_viaq_config_dir }}/*.conf

rsyslog_conf_viaq_mmk8s:

  - name: 'mmk8s'
    type: 'modules'
    path: '{{rsyslog_viaq_config_dir }}'
    state: "{{ 'present'
               if ('viaq-k8s' in rsyslog_capabilities)
               else 'absent' }}"
    sections:

      - options: |-
          # mmkubernetes
          module(load="mmkubernetes")
          
          input(type="imfile" file="{{ rsyslog_viaq_log_dir }}/*.log" tag="kubernetes" addmetadata="on" reopenOnTruncate="on")
          
          if ((strlen($!CONTAINER_NAME) > 0) and (strlen($!CONTAINER_ID_FULL) > 0)) or
              ((strlen($!metadata) > 0) and (strlen($!metadata!filename) > 0) and ($!metadata!filename startswith "{{rsyslog_viaq_log_dir}}/")) then {
              if ((strlen($!metadata) > 0) and (strlen($!metadata!filename) > 0) and ($!metadata!filename startswith "{{rsyslog_viaq_log_dir}}/")) then {
                  if $msg startswith "{" then {
                      action(type="mmjsonparse" cookie="") # parse entire message as json
                  } else {
                      action(type="mmnormalize" rulebase="{{ rsyslog_viaq_config_dir }}/crio.rulebase")
                  }
              }
              action(type="mmkubernetes"
                 filenamerulebase="{{ rsyslog_viaq_config_dir }}/k8s_filename.rulebase"
                 containerrulebase="{{ rsyslog_viaq_config_dir }}/k8s_container_name.rulebase"
                 tls.cacert="{{logging_mmk8s_ca_cert}}"
                 tokenfile="{{logging_mmk8s_token}}" annotation_match=["."])
          }

rsyslog_conf_viaq_elasticsearch:

  - name: 'elasticsearch'
    type: 'output'
    path: '{{rsyslog_viaq_config_dir }}'
    state: "{{ 'present'
               if ('viaq' in rsyslog_capabilities)
               else 'absent' }}"
    sections:

      - options: |-
          # omelasticsearch
          template(name="viaq_template" type="list") {
              property(name="$!all-json-plain")
          }
          template(name="viaq_template_nl" type="list") {
              property(name="$!all-json-plain")
              constant(value="\n")
          }
          
          template(name="prefix_index_template" type="list") {
              property(name="$.viaq_index_prefix")
              property(name="$!@timestamp" dateFormat="rfc3339" position.from="1" position.to="4")
              constant(value=".")
              property(name="$!@timestamp" dateFormat="rfc3339" position.from="6" position.to="7")
              constant(value=".")
              property(name="$!@timestamp" dateFormat="rfc3339" position.from="9" position.to="10")
          }
          
          template(name="index_template" type="string" string="%$.viaq_index_name%")
          template(name="id_template" type="string" string="%$.viaq_msg_id%")
          
          ruleset(name="error_es") {
              action(type="omfile" template="viaq_template_nl" file="{{rsyslog_work_dir}}/es-bulk-errors.log")
          }
          
          ruleset(name="try_es") {
              if strlen($.omes!status) > 0 then {
                  # retry case
                  if ($.omes!status == 200) or ($.omes!status == 201) or (($.omes!status == 409) and ($.omes!writeoperation == "create")) then {
                      stop # successful
                  }
                  if ($.omes!writeoperation == "unknown") or (strlen($.omes!error!type) == 0) or (strlen($.omes!error!reason) == 0) then {
                      call error_es
                      stop
                  }
                  if ($.omes!status == 400) or ($.omes!status < 200) then {
                      call error_es
                      stop
                  }
                  # else fall through to retry operation
              }
              if strlen($!viaq_msg_id) > 0 then {
                  set $.viaq_msg_id = $!viaq_msg_id;
              } else if strlen($.omes!_id) > 0 then {
                  # retry
                  set $.viaq_msg_id = $.omes!_id;
              } else {
                  # NOTE: depends on rsyslog being compiled with --enable-uuid
                  set $.viaq_msg_id = $uuid;
              }
              if strlen($.omes!_index) > 0 then {
                  # retry
                  set $.viaq_index_name = $.omes!_index;
              } else {
                  set $.viaq_index_name = exec_template("prefix_index_template");
              }
          {% for res in rsyslog_elasticsearch_viaq %}
          {% if loop.length == 1 %}
              action(
                  type="omelasticsearch"
                  name="{{ res.name | default('viaq-elasticsearch') }}"
                  server="{{ res.server_host | default('logging-es') }}"
                  serverport="{{ res.server_port | default(9200) | int }}"
                  template="viaq_template"
                  searchIndex="index_template"
                  dynSearchIndex="on"
                  searchType="com.redhat.viaq.common"
                  bulkmode="on"
                  writeoperation="create"
                  bulkid="id_template"
                  dynbulkid="on"
                  retryfailures="on"
                  retryruleset="try_es"
                  usehttps="on"
          {% if use_omelasticsearch_cert | default(False) %}
                  tls.cacert="{{ res.ca_cert }}"
                  tls.mycert="{{ res.cert }}"
                  tls.myprivkey="{{ res.key }}"
          {% endif %}
              )
          {% else %}
          {% if loop.first %}
              if $.viaq_index_prefix startswith "{{ res.index_prefix }}" then {
                action(
                    type="omelasticsearch"
                    name="{{ res.name | default('viaq-elasticsearch') }}"
                    server="{{ res.server_host | default('logging-es') }}"
                    serverport="{{ res.server_port | default(9200) | int }}"
                    template="viaq_template"
                    searchIndex="index_template"
                    dynSearchIndex="on"
                    searchType="com.redhat.viaq.common"
                    bulkmode="on"
                    writeoperation="create"
                    bulkid="id_template"
                    dynbulkid="on"
                    retryfailures="on"
                    retryruleset="try_es"
                    usehttps="on"
            {% if use_omelasticsearch_cert | default(False) %}
                    tls.cacert="{{ res.ca_cert }}"
                    tls.mycert="{{ res.cert }}"
                    tls.myprivkey="{{ res.key }}"
            {% endif %}
                )
          {% elif loop.last %}
              else {
                action(
                    type="omelasticsearch"
                    name="{{ res.name | default('viaq-elasticsearch') }}"
                    server="{{ res.server_host | default('logging-es') }}"
                    serverport="{{ res.server_port | default(9200) | int }}"
                    template="viaq_template"
                    searchIndex="index_template"
                    dynSearchIndex="on"
                    searchType="com.redhat.viaq.common"
                    bulkmode="on"
                    writeoperation="create"
                    bulkid="id_template"
                    dynbulkid="on"
                    retryfailures="on"
                    retryruleset="try_es"
                    usehttps="on"
            {% if use_omelasticsearch_cert | default(False) %}
                    tls.cacert="{{ res.ca_cert }}"
                    tls.mycert="{{ res.cert }}"
                    tls.myprivkey="{{ res.key }}"
            {% endif %}
                )
          {% else %}
              else if $.viaq_index_prefix startswith "{{ res.index_prefix }}" then {
                action(
                    type="omelasticsearch"
                    name="{{ res.name | default('viaq-elasticsearch') }}"
                    server="{{ res.server_host | default('logging-es') }}"
                    serverport="{{ res.server_port | default(9200) | int }}"
                    template="viaq_template"
                    searchIndex="index_template"
                    dynSearchIndex="on"
                    searchType="com.redhat.viaq.common"
                    bulkmode="on"
                    writeoperation="create"
                    bulkid="id_template"
                    dynbulkid="on"
                    retryfailures="on"
                    retryruleset="try_es"
                    usehttps="on"
            {% if use_omelasticsearch_cert | default(False) %}
                    tls.cacert="{{ res.ca_cert }}"
                    tls.mycert="{{ res.cert }}"
                    tls.myprivkey="{{ res.key }}"
            {% endif %}
                )
          {% endif %}
              }
          {% endif %}
          {% endfor %}
          }
          
          call try_es

rsyslog_conf_viaq_viaq_formatting:

  - name: 'viaq_formatting'
    type: 'template'
    path: '{{rsyslog_viaq_config_dir }}'
    state: "{{ 'present'
               if ('viaq' in rsyslog_capabilities)
               else 'absent' }}"
    sections:

      - options: |-
          # formatting
          lookup_table(name="prio_to_level" file="{{ rsyslog_viaq_config_dir }}/prio_to_level.json")
          lookup_table(name="normalize_level" file="{{ rsyslog_viaq_config_dir }}/normalize_level.json")
          
          template(name="cnvt_to_viaq_timestamp" type="list") {
              property(name="TIMESTAMP" dateFormat="rfc3339")
          }
          
          # rsyslog 8.30.0 and later does case insensitive variable name comparison
          # which means $!MESSAGE is the same as $!message - HOWEVER - the case
          # of the variable name is preserved when outputting, so we need to "normalize"
          # to all lower case so that the internal JSON to string conversion will output
          # "message" in the outgoing record
          if strlen($!MESSAGE) > 0 then {
              set $!pipeline_metadata!collector!original_raw_message = $!MESSAGE;
              action(type="mmnormalize" ruleBase="{{ rsyslog_viaq_config_dir }}/parse_json.rulebase" variable="$!MESSAGE")
              # ensure that $!message is set and $!MESSAGE is unset
              # if rsyslog is case sensitive, then $!MESSAGE == $!message
              if $!MESSAGE == $!message then {
                  set $.save_message = $!message;
                  unset $!MESSAGE; # which also unsets $!message
                  set $!message = $.save_message;
                  unset $.save_message;
              } else {
                  if strlen($!message) == 0 then {
                      set $!message = $!MESSAGE;
                  }
                  unset $!MESSAGE;
              }
              unset $!originalmsg;
              unset $!unparsed-data;
          } else {
              if strlen($!log) > 0 then {
                  set $!pipeline_metadata!collector!original_raw_message = $!log;
                  action(type="mmnormalize" ruleBase="{{ rsyslog_viaq_config_dir }}/parse_json.rulebase" variable="$!log")
                  if strlen($!message) == 0 then {
                      set $!message = $!log;
                  }
                  unset $!log;
              }
              unset $!originalmsg;
              unset $!unparsed-data;
          }
          
          if strlen($!_MACHINE_ID) > 0 then {
              # convert from imjournal to viaq systemd format
              # https://github.com/ViaQ/elasticsearch-templates/blob/master/namespaces/systemd.yml
          
              set $!systemd!t!MACHINE_ID = $!_MACHINE_ID;
              unset $!_MACHINE_ID;
              if strlen($!CODE_FILE) > 0 then {
                  set $!systemd!u!CODE_FILE = $!CODE_FILE;
              }
              unset $!CODE_FILE;
              if strlen($!CODE_FUNCTION) > 0 then {
                  set $!systemd!u!CODE_FUNCTION = $!CODE_FUNCTION;
              }
              unset $!CODE_FUNCTION;
              if strlen($!CODE_LINE) > 0 then {
                  set $!systemd!u!CODE_LINE = $!CODE_LINE;
              }
              unset $!CODE_LINE;
              if strlen($!ERRNO) > 0 then {
                  set $!systemd!u!ERRNO = $!ERRNO;
              }
              unset $!ERRNO;
              if strlen($!MESSAGE_ID) > 0 then {
                  set $!systemd!u!MESSAGE_ID = $!MESSAGE_ID;
              }
              unset $!MESSAGE_ID;
              if strlen($!RESULT) > 0 then {
                  set $!systemd!u!RESULT = $!RESULT;
              }
              unset $!RESULT;
              if strlen($!UNIT) > 0 then {
                  set $!systemd!u!UNIT = $!UNIT;
              }
              unset $!UNIT;
              if strlen($!SYSLOG_FACILITY) > 0 then {
                  set $!systemd!u!SYSLOG_FACILITY = $!SYSLOG_FACILITY;
              }
              unset $!SYSLOG_FACILITY;
              if strlen($!SYSLOG_IDENTIFIER) > 0 then {
                  set $!systemd!u!SYSLOG_IDENTIFIER = $!SYSLOG_IDENTIFIER;
              }
              unset $!SYSLOG_IDENTIFIER;
              if strlen($!SYSLOG_PID) > 0 then {
                  set $!systemd!u!SYSLOG_PID = $!SYSLOG_PID;
              }
              unset $!SYSLOG_PID;
              if strlen($!_AUDIT_LOGINUID) > 0 then {
                  set $!systemd!t!AUDIT_LOGINUID = $!_AUDIT_LOGINUID;
              }
              unset $!_AUDIT_LOGINUID;
              if strlen($!_AUDIT_SESSION) > 0 then {
                  set $!systemd!t!AUDIT_SESSION = $!_AUDIT_SESSION;
              }
              unset $!_AUDIT_SESSION;
              if strlen($!_BOOT_ID) > 0 then {
                  set $!systemd!t!BOOT_ID = $!_BOOT_ID;
              }
              unset $!_BOOT_ID;
              if strlen($!_CAP_EFFECTIVE) > 0 then {
                  set $!systemd!t!CAP_EFFECTIVE = $!_CAP_EFFECTIVE;
              }
              unset $!_CAP_EFFECTIVE;
              if strlen($!_CMDLINE) > 0 then {
                  set $!systemd!t!CMDLINE = $!_CMDLINE;
              }
              unset $!_CMDLINE;
              if strlen($!_COMM) > 0 then {
                  set $!systemd!t!COMM = $!_COMM;
              }
              unset $!_COMM;
              if strlen($!_EXE) > 0 then {
                  set $!systemd!t!EXE = $!_EXE;
              }
              unset $!_EXE;
              if strlen($!_GID) > 0 then {
                  set $!systemd!t!GID = $!_GID;
              }
              unset $!_GID;
              if strlen($!_HOSTNAME) > 0 then {
                  set $!systemd!t!HOSTNAME = $!_HOSTNAME;
              }
              unset $!_HOSTNAME;
              if strlen($!_PID) > 0 then {
                  set $!systemd!t!PID = $!_PID;
              }
              unset $!_PID;
              if strlen($!_SELINUX_CONTEXT) > 0 then {
                  set $!systemd!t!SELINUX_CONTEXT = $!_SELINUX_CONTEXT;
              }
              unset $!_SELINUX_CONTEXT;
              if strlen($!_SOURCE_REALTIME_TIMESTAMP) > 0 then {
                  set $!systemd!t!SOURCE_REALTIME_TIMESTAMP = $!_SOURCE_REALTIME_TIMESTAMP;
              }
              unset $!_SOURCE_REALTIME_TIMESTAMP;
              if strlen($!_SYSTEMD_CGROUP) > 0 then {
                  set $!systemd!t!SYSTEMD_CGROUP = $!_SYSTEMD_CGROUP;
              }
              unset $!_SYSTEMD_CGROUP;
              if strlen($!_SYSTEMD_OWNER_UID) > 0 then {
                  set $!systemd!t!SYSTEMD_OWNER_UID = $!_SYSTEMD_OWNER_UID;
              }
              unset $!_SYSTEMD_OWNER_UID;
              if strlen($!_SYSTEMD_SESSION) > 0 then {
                  set $!systemd!t!SYSTEMD_SESSION = $!_SYSTEMD_SESSION;
              }
              unset $!_SYSTEMD_SESSION;
              if strlen($!_SYSTEMD_SLICE) > 0 then {
                  set $!systemd!t!SYSTEMD_SLICE = $!_SYSTEMD_SLICE;
              }
              unset $!_SYSTEMD_SLICE;
              if strlen($!_SYSTEMD_UNIT) > 0 then {
                  set $!systemd!t!SYSTEMD_UNIT = $!_SYSTEMD_UNIT;
              }
              unset $!_SYSTEMD_UNIT;
              if strlen($!_SYSTEMD_USER_UNIT) > 0 then {
                  set $!systemd!t!SYSTEMD_USER_UNIT = $!_SYSTEMD_USER_UNIT;
              }
              unset $!_SYSTEMD_USER_UNIT;
              if strlen($!_TRANSPORT) > 0 then {
                  set $!systemd!t!TRANSPORT = $!_TRANSPORT;
              }
              unset $!_TRANSPORT;
              if strlen($!_UID) > 0 then {
                  set $!systemd!t!UID = $!_UID;
              }
              unset $!_UID;
              if strlen($!_KERNEL_DEVICE) > 0 then {
                  set $!systemd!k!KERNEL_DEVICE = $!_KERNEL_DEVICE;
              }
              unset $!_KERNEL_DEVICE;
              if strlen($!_KERNEL_SUBSYSTEM) > 0 then {
                  set $!systemd!k!KERNEL_SUBSYSTEM = $!_KERNEL_SUBSYSTEM;
              }
              unset $!_KERNEL_SUBSYSTEM;
              if strlen($!_UDEV_SYSNAME) > 0 then {
                  set $!systemd!k!UDEV_SYSNAME = $!_UDEV_SYSNAME;
              }
              unset $!_UDEV_SYSNAME;
              if strlen($!_UDEV_DEVNODE) > 0 then {
                  set $!systemd!k!UDEV_DEVNODE = $!_UDEV_DEVNODE;
              }
              unset $!_UDEV_DEVNODE;
              if strlen($!_UDEV_DEVLINK) > 0 then {
                  set $!systemd!k!UDEV_DEVLINK = $!_UDEV_DEVLINK;
              }
              unset $!_UDEV_DEVLINK;
          
              # these fields require special handling
              if strlen($!level) == 0 then {
                  if strlen($!PRIORITY) > 0 then {
                      set $!level = lookup("prio_to_level", $!PRIORITY);
                  }
              }
              unset $!PRIORITY;
              if strlen($!hostname) == 0 then {
                  if (strlen($!kubernetes) > 0) and (strlen($!kubernetes!host)) > 0 then {
                      set $!hostname = $!kubernetes!host;
                  } else {
                      if strlen($!_HOSTNAME) > 0 then {
                          set $!hostname = $!_HOSTNAME;
                      } else {
                          set $!hostname = $hostname;
                      }
                  }
              }
              unset $!_HOSTNAME;
              if strlen($!@timestamp) == 0 then {
                  # need to figure out how to convert _SOURCE_REALTIME_TIMESTAMP
                  # in the meantime . . .
                  set $!@timestamp = exec_template('cnvt_to_viaq_timestamp');
              }
              unset $!_SOURCE_REALTIME_TIMESTAMP;
              unset $!__REALTIME_TIMESTAMP;
              # end of block that converts imjournal to viaq format
          } else if (strlen($!kubernetes) > 0) and (strlen($!kubernetes!namespace_name) > 0) then {
              if strlen($!hostname) == 0 then {
                  if strlen($!kubernetes!host) > 0 then {
                      set $!hostname = $!kubernetes!host;
                  } else {
                      set $!hostname = $hostname;
                  }
              }
              if strlen($!@timestamp) == 0 then {
                  if strlen($!time) > 0 then {
                      set $!@timestamp = $!time; # assumes json-file log timestamp in rfc3339 format already
                      unset $!time;
                  } else {
                      set $!@timestamp = exec_template('cnvt_to_viaq_timestamp');
                  }
              }
          }
          
          # normalize level
          if strlen($!level) > 0 then {
              set $.lclevel = tolower($!level);
              set $.normlevel = lookup("normalize_level", $.lclevel);
              if $.normlevel == "unknown" then {
                  continue # do nothing - preserve original value
              } else {
                  reset $!level = $.normlevel;
              }
              unset $.lclevel;
              unset $.normlevel;
          } else {
              if $!stream == "stdout" then {
                  set $!level = "info";
              } else {
                  if $!stream == "stderr" then {
                      set $!level = "err";
                  } else {
                      set $!level = "unknown";
                  }
              }
          }
          
          # add eventrouter
          
          if (strlen($!kubernetes) > 0) and (strlen($!kubernetes!namespace_name) > 0) then {
              # see if this is an operations namespace
              if ($!kubernetes!namespace_name == "default") or ($!kubernetes!namespace_name == "openshift") or
                  ($!kubernetes!namespace_name startswith "openshift-") or
                  ($!kubernetes!namespace_name startswith "kube-") then {
                      set $.viaq_index_prefix = ".operations.";
              } else {
                  if strlen($!kubernetes!namespace_id) > 0 then {
                      set $.viaq_index_prefix = "project." & $!kubernetes!namespace_name & "." & $!kubernetes!namespace_id & ".";
                  } else {
                      set $.viaq_index_prefix = ".orphaned.";
                  }
              } 
          } else {
              set $.viaq_index_prefix = ".operations.";
          }
          
          # add pipeline_metadata
          set $!pipeline_metadata!collector!name = "rsyslog";
          set $!pipeline_metadata!collector!inputname = $inputname;
          template(name="timegeneratedrfc3339" type="string" string="%timegenerated:::date-rfc3339%")
          set $!pipeline_metadata!collector!received_at = exec_template("timegeneratedrfc3339");
          # not sure how to get hostname, ipaddr4, ipaddr6, version
          if (strlen($!file) == 0) and (strlen($!metadata) > 0) and (strlen($!metadata!filename) > 0) then {
              set $!file = $!metadata!filename;
          }
          if (strlen($!offset) == 0) and (strlen($!metadata) > 0) and (strlen($!metadata!fileoffset) > 0) then {
              set $!offset = $!metadata!fileoffset;
          }
          unset $!metadata;

rsyslog_rulebase_viaq_k8s_filename:

  - name: 'k8s_filename'
    filename: 'k8s_filename.rulebase'
    nocomment: 'true'
    path: '{{rsyslog_viaq_config_dir }}'
    state: "{{ 'present'
               if ('viaq-k8s' in rsyslog_capabilities)
               else 'absent' }}"
    sections:

      - options: |-
          version=2
          rule=:{{ rsyslog_viaq_log_dir }}/%pod_name:char-to:_%_%namespace_name:char-to:_%_%container_name_and_id:char-to:.%.log

rsyslog_rulebase_viaq_parse_json:

  - name: 'parse_json'
    filename: 'parse_json.rulebase'
    nocomment: 'true'
    path: '{{rsyslog_viaq_config_dir }}'
    state: "{{ 'present'
               if ('viaq' in rsyslog_capabilities)
               else 'absent' }}"
    sections:

      - options: |-
          version=2
          rule=:%.:json%

rsyslog_rulebase_viaq_k8s_container_name:

  - name: 'k8s_container_name'
    filename: 'k8s_container_name.rulebase'
    nocomment: 'true'
    path: '{{rsyslog_viaq_config_dir }}'
    state: "{{ 'present'
               if ('viaq-k8s' in rsyslog_capabilities)
               else 'absent' }}"
    sections:

      - options: |-
          version=2
          rule=:%k8s_prefix:char-to:_%_%container_name:char-to:.%.%container_hash:char-to:_%_%pod_name:char-to:_%_%namespace_name:char-to:_%_%not_used_1:char-to:_%_%not_used_2:rest%
          rule=:%k8s_prefix:char-to:_%_%container_name:char-to:_%_%pod_name:char-to:_%_%namespace_name:char-to:_%_%not_used_1:char-to:_%_%not_used_2:rest%
          # not a kubernetes container
          rule=:%container_name:rest%

rsyslog_json_viaq_normalize_level:

  - name: 'normalize_level'
    filename: 'normalize_level.json'
    nocomment: 'true'
    path: '{{rsyslog_viaq_config_dir }}'
    state: "{{ 'present'
               if ('viaq' in rsyslog_capabilities)
               else 'absent' }}"
    sections:

      - options: |-
          { "version" : 1,
            "nomatch" : "UNKNOWN",
            "type" : "string",
            "table" : [
              {"index": "emerg", "value": "emerg"},
              {"index": "panic", "value": "emerg"},
              {"index": "alert", "value": "alert"},
              {"index": "crit", "value": "crit"},
              {"index": "critical", "value": "crit"},
              {"index": "err", "value": "err"},
              {"index": "error", "value": "err"},
              {"index": "warning", "value": "warning"},
              {"index": "warn", "value": "warning"},
              {"index": "notice", "value": "notice"},
              {"index": "info", "value": "info"},
              {"index": "debug", "value": "debug"},
              {"index": "trace", "value": "trace"},
              {"index": "unknown", "value": "unknown"}
            ]
          }

rsyslog_json_viaq_prio_to_level:

  - name: 'prio_to_level'
    filename: 'prio_to_level.json'
    nocomment: 'true'
    path: '{{rsyslog_viaq_config_dir }}'
    state: "{{ 'present'
               if ('viaq' in rsyslog_capabilities)
               else 'absent' }}"
    sections:

      - options: |-
          { "version" : 1,
            "nomatch" : "UNKNOWN",
            "type" : "array",
            "table" : [
              {"index": 0, "value": "emerg"},
              {"index": 1, "value": "alert"},
              {"index": 2, "value": "crit"},
              {"index": 3, "value": "err"},
              {"index": 4, "value": "warning"},
              {"index": 5, "value": "notice"},
              {"index": 6, "value": "info"},
              {"index": 7, "value": "debug"},
              {"index": 8, "value": "trace"},
              {"index": 9, "value": "unknown"}
            ]
          }

rsyslog_rulebase_viaq_crio:
  - name: 'crio'
    filename: 'crio.rulebase'
    nocomment: 'true'
    path: '{{rsyslog_viaq_config_dir }}'
    state: "{{ 'present'
               if ('viaq-k8s' in rsyslog_capabilities)
               else 'absent' }}"
    sections:
      - options: |-
          version=2
          rule=:%time:word% %stream:word% %logtag:word% %log:rest%
